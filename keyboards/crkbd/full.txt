[[[a.sh]]]
#!/bin/bash

# Clear existing full.txt if it exists
>full.txt

# Loop through all files in the current directory
for file in *; do
    # Skip if it's a directory or the output file itself
    if [ -f "$file" ] && [ "$file" != "full.txt" ]; then
        # Add file title
        echo "[[[${file}]]]" >>full.txt

        # Add file contents
        cat "$file" >>full.txt

        # Add a newline to separate files
        echo "" >>full.txt
    fi
done

echo "All files have been merged into full.txt"

[[[crkbd.c]]]
/*
Copyright 2019 @foostan
Copyright 2020 Drashna Jaelre <@drashna>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "quantum.h"

#ifdef SWAP_HANDS_ENABLE
__attribute__((weak)) const keypos_t PROGMEM hand_swap_config[MATRIX_ROWS][MATRIX_COLS] = {
    // Left
    {{0, 4}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}},
    {{0, 5}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}},
    {{0, 6}, {1, 6}, {2, 6}, {3, 6}, {4, 6}, {5, 6}},
    {{0, 7}, {1, 7}, {2, 7}, {3, 7}, {4, 7}, {5, 7}},
    // Right
    {{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}},
    {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}},
    {{0, 2}, {1, 2}, {2, 2}, {3, 2}, {4, 2}, {5, 2}},
    {{0, 3}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3}}
};
#endif

#ifdef OLED_ENABLE

oled_rotation_t oled_init_kb(oled_rotation_t rotation) {
    if (!is_keyboard_master()) {
        return OLED_ROTATION_180; // flips the display 180 degrees if offhand
    }
    return rotation;
}

static void oled_render_layer_state(void) {
    oled_write_P(PSTR("Layer: "), false);
    switch (get_highest_layer(layer_state)) {
        case 0:
            oled_write_ln_P(PSTR("Default"), false);
            break;
        case 1:
            oled_write_ln_P(PSTR("Lower"), false);
            break;
        case 2:
            oled_write_ln_P(PSTR("Raise"), false);
            break;
        case 3:
            oled_write_ln_P(PSTR("Adjust"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Undef"), false);
            break;
    }
}

char     key_name = ' ';
uint16_t last_keycode;
uint8_t  last_row;
uint8_t  last_col;

static const char PROGMEM code_to_name[60] = {' ', ' ', ' ', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'R', 'E', 'B', 'T', '_', '-', '=', '[', ']', '\\', '#', ';', '\'', '`', ',', '.', '/', ' ', ' ', ' '};

static void set_keylog(uint16_t keycode, keyrecord_t *record) {
    // save the row and column (useful even if we can't find a keycode to show)
    last_row = record->event.key.row;
    last_col = record->event.key.col;

    key_name     = ' ';
    last_keycode = keycode;
    if (IS_QK_MOD_TAP(keycode)) {
        if (record->tap.count) {
            keycode = QK_MOD_TAP_GET_TAP_KEYCODE(keycode);
        } else {
            keycode = 0xE0 + biton(QK_MOD_TAP_GET_MODS(keycode) & 0xF) + biton(QK_MOD_TAP_GET_MODS(keycode) & 0x10);
        }
    } else if (IS_QK_LAYER_TAP(keycode) && record->tap.count) {
        keycode = QK_LAYER_TAP_GET_TAP_KEYCODE(keycode);
    } else if (IS_QK_MODS(keycode)) {
        keycode = QK_MODS_GET_BASIC_KEYCODE(keycode);
    } else if (IS_QK_ONE_SHOT_MOD(keycode)) {
        keycode = 0xE0 + biton(QK_ONE_SHOT_MOD_GET_MODS(keycode) & 0xF) + biton(QK_ONE_SHOT_MOD_GET_MODS(keycode) & 0x10);
    }
    if (keycode > ARRAY_SIZE(code_to_name)) {
        return;
    }

    // update keylog
    key_name = pgm_read_byte(&code_to_name[keycode]);
}

static const char *depad_str(const char *depad_str, char depad_char) {
    while (*depad_str == depad_char)
        ++depad_str;
    return depad_str;
}

static void oled_render_keylog(void) {
    oled_write_char('0' + last_row, false);
    oled_write_P(PSTR("x"), false);
    oled_write_char('0' + last_col, false);
    oled_write_P(PSTR(", k"), false);
    const char *last_keycode_str = get_u16_str(last_keycode, ' ');
    oled_write(depad_str(last_keycode_str, ' '), false);
    oled_write_P(PSTR(":"), false);
    oled_write_char(key_name, false);
    oled_advance_page(true);
}

// static void render_bootmagic_status(bool status) {
//     /* Show Ctrl-Gui Swap options */
//     static const char PROGMEM logo[][2][3] = {
//         {{0x97, 0x98, 0}, {0xb7, 0xb8, 0}},
//         {{0x95, 0x96, 0}, {0xb5, 0xb6, 0}},
//     };
//     if (status) {
//         oled_write_ln_P(logo[0][0], false);
//         oled_write_ln_P(logo[0][1], false);
//     } else {
//         oled_write_ln_P(logo[1][0], false);
//         oled_write_ln_P(logo[1][1], false);
//     }
// }

__attribute__((weak)) void oled_render_logo(void) {
    // clang-format off
    static const char PROGMEM crkbd_logo[] = {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4,
        0};
    // clang-format on
    oled_write_P(crkbd_logo, false);
}

bool oled_task_kb(void) {
    if (!oled_task_user()) {
        return false;
    }
    if (is_keyboard_master()) {
        oled_render_layer_state();
        oled_render_keylog();
    } else {
        oled_render_logo();
    }
    return false;
}

bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        set_keylog(keycode, record);
    }
    return process_record_user(keycode, record);
}
#endif // OLED_ENABLE

[[[halconf.h]]]
#pragma once
#define HAL_USE_I2C TRUE
#include_next <halconf.h>

[[[info.json]]]
{
    "manufacturer": "foostan",
    "url": "https://github.com/foostan/crkbd",
    "maintainer": "qmk",
    "usb": {
        "vid": "0x4653"
    },
    "features": {
        "bootmagic": true,
        "extrakey": true,
        "nkro": true,
        "oled": true,
        "rgblight": false,
        "rgb_matrix": false
    },
    "bootmagic": {
        "matrix": [0, 1]
    },
    "split": {
        "enabled": true,
        "bootmagic": {
            "matrix": [4, 1]
        }
    },
    "layout_aliases": {
        "LAYOUT": "LAYOUT_split_3x6_3"
    },
    "community_layouts": [ "split_3x5_3", "split_3x6_3" ],
    "layouts": {
        "LAYOUT_split_3x5_3": {
            "layout": [
                {"matrix": [0, 1], "x": 0, "y": 0.3},
                {"matrix": [0, 2], "x": 1, "y": 0.1},
                {"matrix": [0, 3], "x": 2, "y": 0},
                {"matrix": [0, 4], "x": 3, "y": 0.1},
                {"matrix": [0, 5], "x": 4, "y": 0.2},

                {"matrix": [4, 5], "x": 8, "y": 0.2},
                {"matrix": [4, 4], "x": 9, "y": 0.1},
                {"matrix": [4, 3], "x": 10, "y": 0},
                {"matrix": [4, 2], "x": 11, "y": 0.1},
                {"matrix": [4, 1], "x": 12, "y": 0.3},

                {"matrix": [1, 1], "x": 0, "y": 1.3},
                {"matrix": [1, 2], "x": 1, "y": 1.1},
                {"matrix": [1, 3], "x": 2, "y": 1},
                {"matrix": [1, 4], "x": 3, "y": 1.1},
                {"matrix": [1, 5], "x": 4, "y": 1.2},

                {"matrix": [5, 5], "x": 8, "y": 1.2},
                {"matrix": [5, 4], "x": 9, "y": 1.1},
                {"matrix": [5, 3], "x": 10, "y": 1},
                {"matrix": [5, 2], "x": 11, "y": 1.1},
                {"matrix": [5, 1], "x": 12, "y": 1.3},

                {"matrix": [2, 1], "x": 0, "y": 2.3},
                {"matrix": [2, 2], "x": 1, "y": 2.1},
                {"matrix": [2, 3], "x": 2, "y": 2},
                {"matrix": [2, 4], "x": 3, "y": 2.1},
                {"matrix": [2, 5], "x": 4, "y": 2.2},

                {"matrix": [6, 5], "x": 8, "y": 2.2},
                {"matrix": [6, 4], "x": 9, "y": 2.1},
                {"matrix": [6, 3], "x": 10, "y": 2},
                {"matrix": [6, 2], "x": 11, "y": 2.1},
                {"matrix": [6, 1], "x": 12, "y": 2.3},

                {"matrix": [3, 3], "x": 3, "y": 3.7},
                {"matrix": [3, 4], "x": 4, "y": 3.7},
                {"matrix": [3, 5], "x": 5, "y": 3.2, "h": 1.5},

                {"matrix": [7, 5], "x": 7, "y": 3.2, "h": 1.5},
                {"matrix": [7, 4], "x": 8, "y": 3.7},
                {"matrix": [7, 3], "x": 9, "y": 3.7}
            ]
        },
        "LAYOUT_split_3x6_3": {
            "layout": [
                {"matrix": [0, 0], "x": 0, "y": 0.3},
                {"matrix": [0, 1], "x": 1, "y": 0.3},
                {"matrix": [0, 2], "x": 2, "y": 0.1},
                {"matrix": [0, 3], "x": 3, "y": 0},
                {"matrix": [0, 4], "x": 4, "y": 0.1},
                {"matrix": [0, 5], "x": 5, "y": 0.2},

                {"matrix": [4, 5], "x": 9, "y": 0.2},
                {"matrix": [4, 4], "x": 10, "y": 0.1},
                {"matrix": [4, 3], "x": 11, "y": 0},
                {"matrix": [4, 2], "x": 12, "y": 0.1},
                {"matrix": [4, 1], "x": 13, "y": 0.3},
                {"matrix": [4, 0], "x": 14, "y": 0.3},

                {"matrix": [1, 0], "x": 0, "y": 1.3},
                {"matrix": [1, 1], "x": 1, "y": 1.3},
                {"matrix": [1, 2], "x": 2, "y": 1.1},
                {"matrix": [1, 3], "x": 3, "y": 1},
                {"matrix": [1, 4], "x": 4, "y": 1.1},
                {"matrix": [1, 5], "x": 5, "y": 1.2},

                {"matrix": [5, 5], "x": 9, "y": 1.2},
                {"matrix": [5, 4], "x": 10, "y": 1.1},
                {"matrix": [5, 3], "x": 11, "y": 1},
                {"matrix": [5, 2], "x": 12, "y": 1.1},
                {"matrix": [5, 1], "x": 13, "y": 1.3},
                {"matrix": [5, 0], "x": 14, "y": 1.3},

                {"matrix": [2, 0], "x": 0, "y": 2.3},
                {"matrix": [2, 1], "x": 1, "y": 2.3},
                {"matrix": [2, 2], "x": 2, "y": 2.1},
                {"matrix": [2, 3], "x": 3, "y": 2},
                {"matrix": [2, 4], "x": 4, "y": 2.1},
                {"matrix": [2, 5], "x": 5, "y": 2.2},

                {"matrix": [6, 5], "x": 9, "y": 2.2},
                {"matrix": [6, 4], "x": 10, "y": 2.1},
                {"matrix": [6, 3], "x": 11, "y": 2},
                {"matrix": [6, 2], "x": 12, "y": 2.1},
                {"matrix": [6, 1], "x": 13, "y": 2.3},
                {"matrix": [6, 0], "x": 14, "y": 2.3},

                {"matrix": [3, 3], "x": 4, "y": 3.7},
                {"matrix": [3, 4], "x": 5, "y": 3.7},
                {"matrix": [3, 5], "x": 6, "y": 3.2, "h": 1.5},

                {"matrix": [7, 5], "x": 8, "y": 3.2, "h": 1.5},
                {"matrix": [7, 4], "x": 9, "y": 3.7},
                {"matrix": [7, 3], "x": 10, "y": 3.7}
            ]
        }
    },
    "rgb_matrix": {
        "driver": "ws2812",
        "max_brightness": 120
    },
    "rgblight": {
        "max_brightness": 120
    }
}

[[[mcuconf.h]]]
#pragma once
#include_next <mcuconf.h>
#undef RP_I2C_USE_I2C0
#define RP_I2C_USE_I2C0 TRUE  // Para I2C0 (GP0/GP1)
#undef RP_I2C_USE_I2C1
#define RP_I2C_USE_I2C1 FALSE

[[[post_config.h]]]
/* Copyright 2020 Christopher Courtney, aka Drashna Jael're  (@drashna) <drashna@live.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#ifndef OLED_FONT_H
#    define OLED_FONT_H "keyboards/crkbd/lib/glcdfont.c"
#endif

[[[readme.md]]]
# Corne Keyboard (CRKBD)

![Crkbd](https://user-images.githubusercontent.com/736191/40575636-6fba63a4-6123-11e8-9ca0-3f990f1f9f4c.jpg)

![Crkbd](https://user-images.githubusercontent.com/736191/40887871-0eead5dc-678a-11e8-9518-e3ad9e5d2bac.png)

A split keyboard with 3x6 vertically staggered keys and 3 thumb keys.
Also, it has the option that use extension keys and rotary encoders.

Keyboard Maintainer: [foostan](https://github.com/foostan/) [@foostan](https://twitter.com/foostan)  
Hardware Supported: Corne PCB
Hardware Availability: [PCB & Case Data](https://github.com/foostan/crkbd)

Flash example for this keyboard of v1 - v3:

```sh
qmk flash -kb crkbd/rev1 -km default
```

Flash example for this keyboard of v4:

```sh
qmk flash -kb crkbd/rev4 -km default
```

See the [build environment setup](https://docs.qmk.fm/#/getting_started_build_tools) and the [make instructions](https://docs.qmk.fm/#/getting_started_make_guide) for more information. Brand new to QMK? Start with our [Complete Newbs Guide](https://docs.qmk.fm/#/newbs).

## Bootloader

The Corne PCBs have a reset and boot buttons next to the TRRS jack to enter in to the bootloader.

Additionally, if you hold down the "Q" or "P" buttons when plugging in that half of the keyboard (per the default QWERTY layout), this will jump to the bootloader and reset the EEPROM (persistent storage).  This would normally be the very top corner-most position, but due to the breakaway column, it's left at Q and P for compatibility. 

## RGB Matrix 
The Corne Keyboard also supports using the RGB Matrix feature, in place of RGB Light.  This provides a better experience when using the keyboard, as it supports a number of per key effects properly.  If you're not using the in switch LEDs, then you may want to pass on doing this. 

In your keymap's `rules.mk` file, add the following: 

```make
RGBLIGHT_ENABLE = no
RGB_MATRIX_ENABLE = yes
```

And in your `config.h` file, add the following:

```c

#ifdef RGB_MATRIX_ENABLE
#   define RGB_MATRIX_KEYPRESSES // reacts to keypresses
// #   define RGB_MATRIX_KEYRELEASES // reacts to keyreleases (instead of keypresses)
#   define RGB_MATRIX_SLEEP // turn off effects when suspended
#   define RGB_MATRIX_FRAMEBUFFER_EFFECTS
// #   define RGB_MATRIX_LED_PROCESS_LIMIT (RGB_MATRIX_LED_COUNT + 4) / 5 // limits the number of LEDs to process in an animation per task run (increases keyboard responsiveness)
// #   define RGB_MATRIX_LED_FLUSH_LIMIT 16 // limits in milliseconds how frequently an animation will update the LEDs. 16 (16ms) is equivalent to limiting to 60fps (increases keyboard responsiveness)
#    define RGB_MATRIX_MAXIMUM_BRIGHTNESS 150 // limits maximum brightness of LEDs to 150 out of 255. Higher may cause the controller to crash. 
#    define RGB_MATRIX_HUE_STEP 8
#    define RGB_MATRIX_SAT_STEP 8
#    define RGB_MATRIX_VAL_STEP 8
#    define RGB_MATRIX_SPD_STEP 10

/* Enable the animations you want/need.  You may need to enable only a small number of these because       *
 * they take up a lot of space.  Enable and confirm that you can still successfully compile your firmware. */
// RGB Matrix Animation modes. Explicitly enabled
// For full list of effects, see:
// https://docs.qmk.fm/#/feature_rgb_matrix?id=rgb-matrix-effects
#    define ENABLE_RGB_MATRIX_ALPHAS_MODS
#    define ENABLE_RGB_MATRIX_GRADIENT_UP_DOWN
#    define ENABLE_RGB_MATRIX_GRADIENT_LEFT_RIGHT
#    define ENABLE_RGB_MATRIX_BREATHING
#    define ENABLE_RGB_MATRIX_BAND_SAT
#    define ENABLE_RGB_MATRIX_BAND_VAL
#    define ENABLE_RGB_MATRIX_BAND_PINWHEEL_SAT
#    define ENABLE_RGB_MATRIX_BAND_PINWHEEL_VAL
#    define ENABLE_RGB_MATRIX_BAND_SPIRAL_SAT
#    define ENABLE_RGB_MATRIX_BAND_SPIRAL_VAL
#    define ENABLE_RGB_MATRIX_CYCLE_ALL
#    define ENABLE_RGB_MATRIX_CYCLE_LEFT_RIGHT
#    define ENABLE_RGB_MATRIX_CYCLE_UP_DOWN
#    define ENABLE_RGB_MATRIX_RAINBOW_MOVING_CHEVRON
#    define ENABLE_RGB_MATRIX_CYCLE_OUT_IN
#    define ENABLE_RGB_MATRIX_CYCLE_OUT_IN_DUAL
#    define ENABLE_RGB_MATRIX_CYCLE_PINWHEEL
#    define ENABLE_RGB_MATRIX_CYCLE_SPIRAL
#    define ENABLE_RGB_MATRIX_DUAL_BEACON
#    define ENABLE_RGB_MATRIX_RAINBOW_BEACON
#    define ENABLE_RGB_MATRIX_RAINBOW_PINWHEELS
#    define ENABLE_RGB_MATRIX_RAINDROPS
#    define ENABLE_RGB_MATRIX_JELLYBEAN_RAINDROPS
#    define ENABLE_RGB_MATRIX_HUE_BREATHING
#    define ENABLE_RGB_MATRIX_HUE_PENDULUM
#    define ENABLE_RGB_MATRIX_HUE_WAVE
#    define ENABLE_RGB_MATRIX_PIXEL_RAIN
#    define ENABLE_RGB_MATRIX_PIXEL_FLOW
#    define ENABLE_RGB_MATRIX_PIXEL_FRACTAL
// enabled only if RGB_MATRIX_FRAMEBUFFER_EFFECTS is defined
#    define ENABLE_RGB_MATRIX_TYPING_HEATMAP
#    define ENABLE_RGB_MATRIX_DIGITAL_RAIN
// enabled only of RGB_MATRIX_KEYPRESSES or RGB_MATRIX_KEYRELEASES is defined
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_SIMPLE
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_WIDE
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_MULTIWIDE
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_CROSS
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_MULTICROSS
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_NEXUS
#    define ENABLE_RGB_MATRIX_SOLID_REACTIVE_MULTINEXUS
#    define ENABLE_RGB_MATRIX_SPLASH
#    define ENABLE_RGB_MATRIX_MULTISPLASH
#    define ENABLE_RGB_MATRIX_SOLID_SPLASH
#    define ENABLE_RGB_MATRIX_SOLID_MULTISPLASH
#endif
```

After this is done, you should be able to use the normal RGB keycodes, but you'll see the RGB Matrix effects in use, giving a much better experience. 

[[[rules.mk]]]
DEFAULT_FOLDER = crkbd/rev1
SERIAL_DRIVER = vendor

